\documentclass[a4paper, twocolumn]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=2.5cm,right=2.5cm,marginparwidth=1.75cm]{geometry}
\usepackage{multicol}
\usepackage{parskip}


%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{float}
\usepackage{subcaption}
\usepackage{float}
\usepackage{listings}

\title{Robot Planning - Target Rescue project}
\author{Luca Sartore}

\begin{document}
\maketitle
\setlength{\parskip}{0.1in}
\setlength{\parindent}{15pt}


\section{Introduction}
This works aim to develop a planning module for a robot in a Target-Rescue scenario.

In this scenario the robot is placed into an environment with some obstacles, some
victims to rescue and an exit point.
The objective of the robot is to rescue as many victims as possible in a certain time
window, and then reach the exit.
Each victim as a value assigned, that the planner must keep into consideration
when selecting which victims to rescue.
The robot also is constrained by the fact that it should move using only dubins curves.

In order to achieve this task the robot's planning module is composed of three main
submodules:
\begin{itemize}
    \item \textbf{Planning graph module:} This module aims to read the map and convert it into a graph
        that can be used for planning. This module in particular has two versions: One based 
        a combinatorial approach, and another that uses a sampling-based strategy.
    \item \textbf{Trajectory planning module:} This module uses the dubins motion equations to find
        a valid trajectory that connect two points of a specific graph with a specific orientation.
        The module also ensures that the path selected is feasible using collision detection.
    \item \textbf{Graph search module:}
        This module uses the previous two in order to find a good route that save as many victims
        as possible. It is based on an A*-like algorithm.
\end{itemize}


\section{Planning graph}
The planning graph was implemented as an interface that convert a ``map'' (a simple
data structure containing data about victims obstacles ecc.) into a graph.

This is done in two possible ways, one is combinatorial (\ref{sec:comb}) and the other is sampling-based (\ref{sec:samp}).
For the sampling-based approach, collision detection capabilities are also required (\ref{sec:cd}).


\subsection{Collision detection module}
\label{sec:cd}

The collision detection module is designed to be extremely quick, and this is achieved
by giving up a bit of accuracy.

This is done by splitting the map-space into a $1000 \times 1000$ grid.
Obstacles and map borders are then ``drawn'' in the grid.
Then a dilation \cite{dilation} is applied, with a circular kernel with 
radius equal to the radius of the robot (plus a small margin).

In such a way to understand if a certain position is collision free or not.
we can simply check the gir's square that is the best approximation of the position.
This is an acceptable approximation (assuming that the grid is large enough)
and perhaps most importantly is extremely fast, with every operation having
$o(1)$ time complexity.

To check wether a path is collision free or not, the path is approximated as a list
of point with a certain resolution (In this work the resolution used was 5 points per unit of distance)
and then each point is individually checked.
\subsection{Combinatorial Planning graph}
\label{sec:comb}

There are many different combinatorial strategy that be adopted,
``Triangular Decomposition'', ``Trapezoidal Decomposition'' and ``Approximate Cell Decomposition''
just to name a few.

For this, work the triangle-based strategy was selected.
The decision was motivated primely by the observation that graph obtained
using triangle are usually more ``smooth'' than graph opened using trapezoids.
Approximate cell Decomposition was not selected due to the fact that
it generally produces much larger graphs than the first two, which would
result in higher computational costs.

This was not necessary the fastest option in terms of time complexity, however as we will see in the 
result section (\ref{sec:results}) the triangulation execution time is almost negligible when
compared to the downstream steps.

\subsubsection{Implementation details}

\begin{figure*}[!hbt]
    \centering
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{./images/raw_triangulation.png}
        \caption{Raw triangulation}
        \label{fig:raw_triang}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{./images/raw_graph.png}
        \caption{Graph generated by raw triangulation}
        \label{fig:raw_graph}
    \end{subfigure}
    
    \vspace{0.5cm}
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{./images/flip_triangulation.png}
        \caption{Flip triangulation}
        \label{fig:flip_triang}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{./images/fliip_graph.png}
        \caption{Graph generated by flip triangulation}
        \label{fig:flip_graph}
    \end{subfigure}
    \caption{Comparison between different triangulation methods}
    \label{fig:triangulation}
\end{figure*}
The implementation was done in a straightforward way. All edges were considered pairwise,
and only considered valid if they did not intersect any obstacle.
After this a subset of the valid vertexes is selected to form a valid triangulation.

Note that this procedure has a time complexity of $o(n^3)$ and there are more efficient 
implementations, the simpler implementation was selected as an improvement
in speed here is negligible due to the downstream processing being much heaver.

The way arches are selected to form a valid triangulation is not straightforward.
A ``simple'' solution that simply pick a subset of arches that don't intersects with
each other can result in a triangulation that has many long and skinny rectangles,
such as the one sown in figure \ref{fig:raw_triang}.
This strange triangulation will then result in a graph that is hard to 
navigate, as we can observation in figure \ref{fig:raw_graph}

To solve this issue the flip \cite{flip} algorithm was applied, resulting
in a much better triangulation, and by extension graph.
The results can be seen in figure \ref{fig:flip_triang} and \ref{fig:flip_graph}

Another issue with the generated graph is that there are some ``zig-zag'' sometimes.
Those are due to the fact that nodes are placed in the center of triangles as well as
in the in the center of the sides.
This particular path can be annoying for the robot to follow, and therefore an easy
solution was to add `skip-ahead' connection to the graph.
In simple terms this means adding some direct connections
from a node, to all the nodes that can be reached in two steps.
It is important to note that those new connections may not necessary be collision-free,
however they will be checked for collision in the next step and
be discarded if they are found to cause any issue. 
Overall this addition made the path of the root much smoother.





\subsection{Sampling Planning graph}
\label{sec:samp}

The sampling planning graph was obtained by first
generating a random set of points (and ensuring that
every generated point is a valid position of the robot
by using the collision detection module \ref{sec:cd})

Then the K-nearest neighbors of each node were selected,
and nodes were added if an only if the direct path
between the two nodes was judged to be valid by the collision
detection system (\ref{sec:cd}).

In this section a KD-tree was used to facilitate
the retrieval of the K-nearest neighbors in an
efficient manner.

Skip-connections were also added to this graph. They were not as important
as they were in the combinatorial case, but they did have a minor improvement
on the graph. The output graph (before skip-connection were applied) can be seen 
in figure \ref{fig:samp_graph}

\begin{figure}[H]
\centering
\includegraphics[width=0.45\textwidth]{./images/sampling_graph.png}
\caption{Graph obtained using sampling}
\label{fig:samp_graph}
\end{figure}


\section{Trajectory Planning}

The trajectory planning is the simplest module of the project.
It simply test all the dubins combinations (LSL, LSR, RSL, RSR, LRL, RLR)
and pick the shortest one among the one that are collision free.

The collisions are checked using the collision detection module \ref{sec:cd}
and the time complexity is therefore $o(L)$ where $L$ is the length of 
the trajectory.

The module generate 64 trajectories for each edge of the planning graph
(given that it considers all the combinations of 8 start angles and 8 end
angles). This is definitely one of the slowest part of the program, however
it is pretty easy to parallelize, and as we can see in the results section (\ref{sec:results})
the computation time are quite manageable.

\section{Graph search module} 

The final step needed to complete the planner is the graph search module.
This one takes the graph and the trajectories generated by the previous two 
modules and find a trajectory that maximizes the value of the victims
saved while ensuring it reaches the exit within a certain time limit.

The problem presented can be split into two separate problem: One 
is to figure out which victims to save, and what is the optimal
pick-up order, and the other is to find the optimal path
that picks up the victims in the decided order.
We will therefore analyze the two problems separately in
sections \ref{sec:pf} and \ref{sec:of} respectively.

\subsection{Optimal path finding}
\label{sec:pf}
\subsubsection{Problem definition}
In this problem we are given a Graph with a starting point
an ending point, as well as a set of nodes that we need to visit
in a specific order before exiting the graph.
There is also one specific constraint that make it so that the
edges we can use to exit a node, depend on the edge
that we used to reaching the node (more specifically they depend
on the angle used when entering/exiting a node).
This constraint is necessary to ensure that the dubins path
selected are continuous at every node.

The goal is to reach the end in the shortest possible time (or distance)
while still satisfying all the aforementioned constraints.

\subsubsection{Implemented solution}

The proposed solution can be seen as a version of A*
with some minor modifications that allow it to 
satisfy the specific constraints of the problem.

The main modification w.r.t. A* is how we considered a node ``visited'':
In the traditional A* the state of nodes visited is simply
a set containing the IDs of the nodes visited.
However in this modified version the set contains a triplet:
$$<node\_id,\, arriving\_angle,\, next\_objective>$$
This is done to keep into account the fact that a node visited
can be visited again if either it is visited by arriving with a
different angle, or if the next objective in the list of nodes
to visit has changed.

The other part that is slightly
\begin{lstlisting}[language=Python]

# graph data structure
graph = {}

# ordered list of nodes to visit
objectives = [...]
    
# empty set with visited nodes
visited = {}

# priority queue
queue = {0, {
    start_node,
    start_angle,
    objective[0]
}}

while not queue.empty:
  # getting cost, node id,
  # angle and next objective
  # of the first node
  # in the queue
  cost, next = queue.pop
  node, angle, obj = next

  # avoid revisiting nodes
  if [node angle obj] in visited:
    continue

  # found the solution
  if node == graph.exit:
    return

  if node == obj:
    obj = next_obj(obj)

  # iterate over all the edges 
  # that start from node 'node'
  # and start with angle 'angle'
  for e in graph.edges(node, angle):
    # calculate heuristic estimated
    # cost to terminate the journey
    h = heuristic(e.next_node, obj)
    
    # find lower bound cost
    # of current path
    new_cost = cost + e.edge_cost + h

    queue.push(
        e.next_node,
        new_cost,
        obj
    )
\end{lstlisting}





\subsection{Optimal rescue order finding}
\label{sec:of}

\section{results}

\label{sec:results}

\begin{thebibliography}{9}



\bibitem{dilation}
\href{https://it.overleaf.com/learn/latex/Bibliography_management_with_bibtex}{OpenCV - Tutorial erosion and dilation}

\bibitem{flip}
Y. Jiang, Y.-t. Liu, and F. Zhang (2010) \emph{An efficient algorithm for constructing Delaunay triangulation}

\bibitem{lamport94}
Leslie Lamport (2010) \emph{\LaTeX: a document preparation system}, Addison
Wesley, Massachusetts, 2nd ed.
\end{thebibliography}

\end{document}
